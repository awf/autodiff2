#pragma once
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include <stdio.h>
#include <math.h>

/*
  Differentiation of sqsum in forward (tangent) mode:
   variations   of useful results: sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double sqsum_d(int n, double *x, double *xd, double *sqsum) {
    int i;
    double res;
    double resd;
    res = 0;
    resd = 0.0;
    for (i = 0; i < n; ++i) {
        resd = resd + xd[i]*x[i] + x[i]*xd[i];
        res = res + x[i]*x[i];
    }
    *sqsum = res;
    return resd;
}

/*
  Differentiation of cross in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_d0(double *a, double *ad, double *b, double *bd, double *out, 
        double *outd) {
    outd[0] = ad[1]*b[2] + a[1]*bd[2] - ad[2]*b[1] - a[2]*bd[1];
    out[0] = a[1]*b[2] - a[2]*b[1];
    outd[1] = ad[2]*b[0] + a[2]*bd[0] - ad[0]*b[2] - a[0]*bd[2];
    out[1] = a[2]*b[0] - a[0]*b[2];
    outd[2] = ad[0]*b[1] + a[0]*bd[1] - ad[1]*b[0] - a[1]*bd[0];
    out[2] = a[0]*b[1] - a[1]*b[0];
}

/*
  Differentiation of dot_prod in forward (tangent) mode:
   variations   of useful results: dot_prod
   with respect to varying inputs: *x *y
   Plus diff mem management of: x:in y:in
*/
double dot_prod_d(int n, double *x, double *xd, double *y, double *yd, double 
        *dot_prod) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < n; ++i) {
        resd = resd + xd[i]*y[i] + x[i]*yd[i];
        res += x[i]*y[i];
    }
    *dot_prod = res;
    return resd;
}

/*
  Differentiation of ba_rod_single in forward (tangent) mode:
   variations   of useful results: alloc(*cross_) alloc(*w) *rotatedPt
   with respect to varying inputs: alloc(*cross_) alloc(*w) *rot
                *rotatedPt *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void ba_rod_single_d(double *rot, double *rotd, double *pt, double *ptd, 
        double *rotatedPt, double *rotatedPtd) {
    int i;
    double sqtheta, theta, costheta, sintheta, theta_inverse, tmp;
    double sqthetad, thetad, costhetad, sinthetad, theta_inversed, tmpd;
    double *w;
    double *wd;
    double result1;
    double result1d;
    int ii1;
    wd = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        wd[ii1] = 0.0;
    w = (double *)malloc(sizeof(double)*3);
    double *cross_;
    double *cross_d;
    cross_d = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        cross_d[ii1] = 0.0;
    cross_ = (double *)malloc(sizeof(double)*3);
    sqthetad = sqsum_d(3, rot, rotd, &sqtheta);
    thetad = (sqtheta == 0.0 ? 0.0 : sqthetad/(2.0*sqrt(sqtheta)));
    theta = sqrt(sqtheta);
    // printf("theta %f, %f\n", theta, thetad);
    costhetad = -(thetad*sin(theta));
    costheta = cos(theta);
    sinthetad = thetad*cos(theta);
    sintheta = sin(theta);
    theta_inversed = -(thetad/(theta*theta));
    theta_inverse = 1.0/theta;
    for (i = 0; i < 3; ++i) {
        wd[i] = rotd[i]*theta_inverse + rot[i]*theta_inversed;
        w[i] = rot[i]*theta_inverse;
    }
    // printf("thetai %f\n", theta_inversed);
    cross_d0(w, wd, pt, ptd, cross_, cross_d);
    // // printf("[");
    // for (int i = 0; i < 3; i++) {
    //   // printf("(%f, %f)", cross_[i], cross_d[i]);
    //   // printf("sub %f, %f\n", pt[i], ptd[i]);
    //   // printf("w %f, %f\n", w[i], wd[i]);
    //   // printf("rot %f, %f\n", rot[i], rotd[i]);
    //   // printf("w %f\n", wd[i]);
    //   // if (i != 3 - 1)
    //   //   printf(", ");
    // }
    // // printf("]\n");
    result1d = dot_prod_d(3, w, wd, pt, ptd, &result1);
    tmpd = result1d*(1.-costheta) - result1*costhetad;
    tmp = result1*(1.-costheta);
    // printf("dot %f, %f\n", result1, result1d);
    // printf("tmp %f, %f\n", tmp, tmpd);
    for (i = 0; i < 3; ++i) {
        rotatedPtd[i] = ptd[i]*costheta + pt[i]*costhetad + cross_d[i]*
            sintheta + cross_[i]*sinthetad + wd[i]*tmp + w[i]*tmpd;
        rotatedPt[i] = pt[i]*costheta + cross_[i]*sintheta + w[i]*tmp;
    }
    // printf("[");
    // for (int i = 0; i < 3; i++) {
    //   printf("(%f, %f)", rotatedPt[i], rotatedPtd[i]);
    //   if (i != 3 - 1)
    //     printf(", ");
    // }
    // printf("]\n");
    free(wd);
    free(w);
    free(cross_d);
    free(cross_);
}

/*
  Differentiation of ba_rod_native in forward (tangent) mode:
   variations   of useful results: alloc(*cross_) alloc(*w) **res
   with respect to varying inputs: alloc(*cross_) alloc(*w) **res
                *xs
   RW status of diff variables: alloc(*cross_):in-out alloc(*w):in-out
                **res:in-out *xs:in
   Plus diff mem management of: res:in *res:in xs:in
*/
void ba_rod_native_d(int d, double *xs, double *xsd, int n, double **res, 
        double **resd) {
    for (int idx = 0; idx < n; ++idx) {
        int offset = 11 + d*idx;
        ba_rod_single_d(xs, xsd, &xs[offset], &xsd[offset], res[idx], resd[idx
                        ]);
    }
}

/*
  Differentiation of radial_distort in forward (tangent) mode:
   variations   of useful results: *res
   with respect to varying inputs: *res *rad_params *proj
   Plus diff mem management of: res:in rad_params:in proj:in
*/
void radial_distort_d(double *rad_params, double *rad_paramsd, double *proj, 
        double *projd, double *res, double *resd) {
    double rsq, L;
    double rsqd, Ld;
    rsqd = sqsum_d(2, proj, projd, &rsq);
    // printf("rsq %f, %f\n", rsq, rsqd);
    Ld = rad_paramsd[0]*rsq + rad_params[0]*rsqd + rad_paramsd[1]*(rsq*rsq) + 
        rad_params[1]*(rsqd*rsq+rsq*rsqd);
    L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    // printf("L %f, %f\n", L, Ld);
    resd[0] = projd[0]*L + proj[0]*Ld;
    res[0] = proj[0]*L;
    resd[1] = projd[1]*L + proj[1]*Ld;
    res[1] = proj[1]*L;
}

/*
  Differentiation of project in forward (tangent) mode:
   variations   of useful results: alloc(*proj3) alloc(*proj2)
                alloc(*Xcam) alloc(*Xo) alloc(*cross_) alloc(*w)
                *proj
   with respect to varying inputs: alloc(*proj3) alloc(*proj2)
                alloc(*Xcam) alloc(*Xo) alloc(*cross_) alloc(*w)
                *cam *X *proj
   Plus diff mem management of: cam:in X:in proj:in
*/
void project_d(double *cam, double *camd, double *X, double *Xd, double *proj,
        double *projd) {
    int i;
    double *C;
    double *Cd;
    double *Xo;
    double *Xod;
    int ii1;
    Xod = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xod[ii1] = 0.0;
    Xo = (double *)malloc(sizeof(double)*3);
    double *Xcam;
    double *Xcamd;
    Xcamd = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xcamd[ii1] = 0.0;
    Xcam = (double *)malloc(sizeof(double)*3);
    double *proj2;
    double *proj2d;
    proj2d = (double *)malloc(sizeof(double)*2);
    for (ii1 = 0; ii1 < 2; ++ii1)
        proj2d[ii1] = 0.0;
    proj2 = (double *)malloc(sizeof(double)*2);
    double *proj3;
    double *proj3d;
    proj3d = (double *)malloc(sizeof(double)*2);
    for (ii1 = 0; ii1 < 2; ++ii1)
        proj3d[ii1] = 0.0;
    proj3 = (double *)malloc(sizeof(double)*2);
    Cd = &camd[3];
    C = &cam[3];
    for (i = 0; i < 3; ++i) {
        Xod[i] = Xd[i] - Cd[i];
        Xo[i] = X[i] - C[i];
    }
    ba_rod_single_d(&cam[0], &camd[0], Xo, Xod, Xcam, Xcamd);
    // printf("[");
    // // for (int i = 0; i < 14; i++) {
    // for (int i = 0; i < 3; i++) {
    //   printf("(%f, %f)", Xcam[i], Xcamd[i]);
    //   // printf("(%f, %f)", Xo[i], Xod[i]);
    //   // printf("%f", camd[i]);
    //   // if (i != 14 - 1)
    //   if (i != 3 - 1)
    //     printf(", ");
    // }
    // printf("]\n");
    proj2d[0] = (Xcamd[0]*Xcam[2]-Xcam[0]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj2[0] = Xcam[0]/Xcam[2];
    proj2d[1] = (Xcamd[1]*Xcam[2]-Xcam[1]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj2[1] = Xcam[1]/Xcam[2];
    radial_distort_d(&cam[9], &camd[9], proj2, proj2d, proj3, proj3d);
    for (i = 0; i < 2; ++i) {
        projd[i] = proj3d[i]*cam[6] + proj3[i]*camd[6] + camd[7 + i];
        proj[i] = proj3[i]*cam[6] + cam[7 + i];
    }
    // printf("[");
    // for (int i = 0; i < 2; i++) {
    //   printf("(%f, %f)", proj[i], projd[i]);
    //   if (i != 2 - 1)
    //     printf(", ");
    // }
    // printf("]\n");
    free(Xod);
    free(Xo);
    free(Xcamd);
    free(Xcam);
    free(proj2d);
    free(proj2);
    free(proj3d);
    free(proj3);
}
/*
  Differentiation of ba_proj_native in forward (tangent) mode:
   variations   of useful results: alloc(*proj3) alloc(*proj2)
                alloc(*Xcam) alloc(*Xo) alloc(*cross_) alloc(*w)
                **res
   with respect to varying inputs: alloc(*proj3) alloc(*proj2)
                alloc(*Xcam) alloc(*Xo) alloc(*cross_) alloc(*w)
                **res *xs
   RW status of diff variables: alloc(*proj3):in-out alloc(*proj2):in-out
                alloc(*Xcam):in-out alloc(*Xo):in-out alloc(*cross_):in-out
                alloc(*w):in-out **res:in-out *xs:in
   Plus diff mem management of: res:in *res:in xs:in
*/
void ba_proj_native_d(int d, double *xs, double *xsd, int n, double **res, 
        double **resd) {
    for (int idx = 0; idx < n; ++idx) {
        int offset = 11 + d*idx;
        project_d(xs, xsd, &xs[offset], &xsd[offset], res[idx], resd[idx]);
    }
}