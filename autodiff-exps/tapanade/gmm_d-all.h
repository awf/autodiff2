#pragma once

/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6665M) - 27 Nov 2017 15:43
*/
#include <math.h>

/*
  Differentiation of arr_max in forward (tangent) mode:
   variations   of useful results: arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double arr_max_d(int n, double *x, double *xd, double *arr_max) {
    double m;
    double md;
    int i;
    md = xd[0];
    m = x[0];
    for (i = 1; i < n; ++i)
        if (x[i] > m) {
            md = xd[i];
            m = x[i];
        }
    *arr_max = m;
    return md;
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double logsumexp_d(int n, double *x, double *xd, double *logsumexp) {
    int i;
    double mx, semx;
    double mxd, semxd;
    mxd = arr_max_d(n, x, xd, &mx);
    semx = 0.;
    semxd = 0.0;
    for (i = 0; i < n; ++i) {
        semxd = semxd + (xd[i]-mxd)*exp(x[i]-mx);
        semx += exp(x[i] - mx);
    }
    *logsumexp = log(semx) + mx;
    return semxd/semx + mxd;
}

/*
  Differentiation of sqnorm in forward (tangent) mode:
   variations   of useful results: sqnorm
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double sqnorm_d(int d, double *x, double *xd, double *sqnorm) {
    int i;
    double out;
    double outd;
    out = 0;
    outd = 0.0;
    for (i = 0; i < d; ++i) {
        outd = outd + xd[i]*x[i] + x[i]*xd[i];
        out += x[i]*x[i];
    }
    *sqnorm = out;
    return outd;
}

/*
  Differentiation of log_wishart_prior in forward (tangent) mode:
   variations   of useful results: log_wishart_prior
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in
*/
double log_wishart_prior_d(int p, int k, double wishart_gamma, double 
        wishart_m, double *sum_qs, double *sum_qsd, double *Qdiags, double *
        Qdiagsd, double *icf, double *icfd, double *log_wishart_prior) {
    int n, ik, icf_sz;
    double out, C, frobenius;
    double outd, frobeniusd;
    double result1;
    double result1d;
    double result2;
    double result2d;
    icf_sz = p*(p+1)/2;
    out = 0;
    outd = 0.0;
    for (ik = 0; ik < k; ++ik) {
        result1d = sqnorm_d(p, &Qdiags[ik*p], &Qdiagsd[ik*p], &result1);
        result2d = sqnorm_d(icf_sz - p, &icf[ik*icf_sz + p], &icfd[ik*icf_sz +
                            p], &result2);
        frobeniusd = result1d + result2d;
        frobenius = result1 + result2;
        outd = outd + 0.5*frobeniusd;
        out = out + 0.5*frobenius;
    }
    *log_wishart_prior = out;
    /* *wishart.gamma*wishart.gamma 
-wishart.m */
    // the last bit is here so that tapenade would recognize that means and inv_cov_factors are variables
    return outd;
}

/*
  Differentiation of preprocess_qs in forward (tangent) mode:
   variations   of useful results: *Qdiags *sum_qs
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in

 - k*C + (Qdiags[0] - Qdiags[0]) + (icf[0] - icf[0]) */
void preprocess_qs_d(int d, int k, double *icf, double *icfd, double *sum_qs, 
        double *sum_qsd, double *Qdiags, double *Qdiagsd) {
    int icf_sz, ik, id;
    double q;
    double qd;
    icf_sz = d*(d+1)/2;
    for (ik = 0; ik < k; ++ik) {
        sum_qsd[ik] = 0.0;
        sum_qs[ik] = 0.;
        for (id = 0; id < d; ++id) {
            qd = icfd[ik*icf_sz + id];
            q = icf[ik*icf_sz + id];
            sum_qsd[ik] = sum_qsd[ik] + qd;
            sum_qs[ik] += q;
            Qdiagsd[ik*d + id] = qd*exp(q);
            Qdiags[ik*d + id] = exp(q);
        }
    }
}

/*
  Differentiation of Qtimesx in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *Qdiag *x *ltri
   Plus diff mem management of: out:in Qdiag:in x:in ltri:in
*/
void Qtimesx_d(int d, double *Qdiag, double *Qdiagd, double *ltri, double *
        ltrid, double *x, double *xd, double *out, double *outd) {
    // strictly lower triangular part
    int id, i, j, Lparamsidx;
    for (id = 0; id < d; ++id) {
        outd[id] = Qdiagd[id]*x[id] + Qdiag[id]*xd[id];
        out[id] = Qdiag[id]*x[id];
    }
    Lparamsidx = 0;
    for (i = 0; i < d; ++i)
        for (j = i+1; j < d; ++j) {
            outd[j] = outd[j] + ltrid[Lparamsidx]*x[i] + ltri[Lparamsidx]*xd[i
                ];
            out[j] = out[j] + ltri[Lparamsidx]*x[i];
            Lparamsidx = Lparamsidx + 1;
        }
}

/*
  Differentiation of subtract in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *x *y
   Plus diff mem management of: out:in x:in y:in
*/
// out = a - b
void subtract_d(int d, double *x, double *xd, double *y, double *yd, double *
        out, double *outd) {
    int id;
    for (id = 0; id < d; ++id) {
        outd[id] = xd[id] - yd[id];
        out[id] = x[id] - y[id];
    }
}
